// Code.gs - 서버 사이드 코드

// 웹 앱 실행 시 HTML 페이지 반환
function doGet() {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('교원 현황표')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
    .addMetaTag('viewport', 'width=device-width, initial-scale=1')
    .setSandboxMode(HtmlService.SandboxMode.IFRAME);
}

// HTML 파일에 다른 파일 포함하기 위한 함수
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

// 스프레드시트에서 교원 데이터 가져오기
function getFacultyData() {
  try {
    // ===== 중요: 아래 ID를 실제 스프레드시트 ID로 변경하세요 =====
    // 스프레드시트 URL에서 ID 찾기:
    // https://docs.google.com/spreadsheets/d/{이 부분이 ID}/edit
    const SPREADSHEET_ID = '1QGFHEnF7TD9MpxDyuDUPcoELDNvOMM_TpiQ11bOdUPY'; // 실제 ID로 변경 필수!
    
    // ID가 변경되지 않았다면 오류 발생
    if (SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      throw new Error('스프레드시트 ID를 설정해주세요. Code.gs 파일의 SPREADSHEET_ID를 실제 ID로 변경하세요.');
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = spreadsheet.getSheetByName('교원현황_정리본');
    
    if (!sheet) {
      throw new Error('교원현황_정리본 시트를 찾을 수 없습니다.');
    }
    
    const data = sheet.getDataRange().getValues();
    console.log('총 데이터 행 수:', data.length);
    
    // 데이터 처리
    const processedData = processData(data);
    
    return {
      success: true,
      data: processedData
    };
    
  } catch (error) {
    console.error('Error in getFacultyData:', error);
    return {
      success: false,
      error: error.toString()
    };
  }
}

// 데이터 처리 함수
function processData(data) {
  // 직급 매핑
  const positionMapping = {
    '교  수': '교수',
    '교수': '교수',
    '부교수': '부교수',
    '조교수': '조교수',
    '부교수(비정년트랙)': '부교수(비정년트랙)',
    '조교수(비정년트랙)': '조교수(비정년트랙)',
    '특임교수': '특임교수',
    '객원교수': '객원교수',
    '겸임교원': '겸임교원',
    '겸임교원(비전임)': '겸임교원',
    '겸임교수': '겸임교원',
    '겸임부교수': '겸임교원',
    '겸임조교수': '겸임교원',
    '겸임조교수.': '겸임교원',
    '초빙교원': '초빙교원',
    '초빙교원(비전임)': '초빙교원',
    '강사': '강사',
    '시간강사': '강사',
    '명예교수': '명예교수'
  };
  
  // 기타 직급 매핑
  const otherPositionMapping = {
    '특별연구원': '특별연구원',
    '학술연구교수': '학술연구교수',
    '전임연구원': '전임연구원',
    '학예연구사': '학예연구사',
    '전문상담원': '전문상담원',
    '전임지도자': '전임지도자',
    '기술감독': '기술감독'
  };
  
  // 부서 구조 및 학과 정렬 순서
  const deptStructure = [
    { 
      name: '대학원', 
      subDepts: ['교육대학원', '일반대학원', '재활복지대학원', '태권도대학원', '문화예술대학원', '스포츠과학대학원'] 
    },
    { 
      name: '무도대학', 
      subDepts: ['유도학과', '유도경기지도학과', '무도학과', '태권도학과', '경호학과', '군사학과', '무도스포츠산업학과(계약학과)']
    },
    { 
      name: '체육과학대학', 
      subDepts: ['스포츠레저학과', '특수체육교육과', '체육학과', '골프학부']
    },
    { 
      name: '문화예술대학', 
      subDepts: ['무용과', '미디어디자인학과', '영화영상학과', '회화학과', '국악과', '연극학과', '문화유산학과', '문화콘텐츠학과', '실용음악과']
    },
    { 
      name: '인문사회융합대학', 
      subDepts: ['경영학과', '관광경영학과', '경영정보학과', '경찰행정학과', '영어과', '중국학과', '미용경영학과', '미용경영학과(야)', '사회복지학과']
    },
    { 
      name: 'AI바이오융합대학', 
      subDepts: ['AI융합학부', '환경학과', '보건환경안전학과', '바이오생명공학과', '식품조리학부', '물리치료학과']
    },
    { name: '용오름대학', subDepts: [] },
    { name: '산학협력단', subDepts: [] },
    { name: '평가성과분석센터', subDepts: [] },
    { name: '교육혁신원', subDepts: [] },
    { name: '박물관', subDepts: [] },
    { name: '체육지원실', subDepts: [] },
    { name: '교수학습지원센터', subDepts: [] },
    { name: '스포츠.웰니스연구센터', subDepts: [] },
    { name: '특수체육연구소', subDepts: [] },
    { name: '무도연구소', subDepts: [] },
    { name: '혁신사업추진단', subDepts: [] },
    { name: '학생생활상담센터', subDepts: [] },
    { name: '취창업지원센터', subDepts: [] },
    { name: '인권센터', subDepts: [] }
  ];
  
  const fullTimePositions = ['교수', '부교수', '조교수', '부교수(비정년트랙)', '조교수(비정년트랙)'];
  const partTimePositions = ['특임교수', '객원교수', '겸임교원', '초빙교원', '강사', '명예교수'];
  const otherPositions = ['특별연구원', '학술연구교수', '전임연구원', '학예연구사', '전문상담원', '전임지도자', '기술감독'];
  
  // 헤더에서 컬럼 인덱스 찾기
  const headers = data[0];
  const colIndex = {
    college: headers.indexOf('대학') >= 0 ? headers.indexOf('대학') : 0,
    dept: headers.indexOf('소속') >= 0 ? headers.indexOf('소속') : 1,
    empNo: headers.indexOf('직번') >= 0 ? headers.indexOf('직번') : 2,
    name: headers.indexOf('성명') >= 0 ? headers.indexOf('성명') : 3,
    serialType: headers.indexOf('직렬') >= 0 ? headers.indexOf('직렬') : 4,
    position: headers.indexOf('직급') >= 0 ? headers.indexOf('직급') : 5,
    gender: headers.indexOf('성별') >= 0 ? headers.indexOf('성별') : 6,
    status: headers.indexOf('재직구분') >= 0 ? headers.indexOf('재직구분') : 8,
    salary: headers.indexOf('호봉') >= 0 ? headers.indexOf('호봉') : 12,
    firstAppointmentStart: headers.indexOf('최초임용 시작일') >= 0 ? headers.indexOf('최초임용 시작일') : 18,
    firstAppointmentEnd: headers.indexOf('최초임용 종료일') >= 0 ? headers.indexOf('최초임용 종료일') : 19,
    reappointmentEnd: headers.indexOf('재임용종료일') >= 0 ? headers.indexOf('재임용종료일') : 22,
    birthDate: headers.indexOf('생년월일') >= 0 ? headers.indexOf('생년월일') : 28,
    retirementDate: headers.indexOf('정년일자') >= 0 ? headers.indexOf('정년일자') : -1
  };
  
  console.log('컬럼 인덱스:', colIndex);
  
  // 결과 객체 초기화
  const result = {};
  
  // 결과 객체 초기화 (학과 정보 포함)
  deptStructure.forEach(dept => {
    if (dept.name === '대학원' || (dept.subDepts && dept.subDepts.length > 0)) {
      result[dept.name] = {};
      dept.subDepts.forEach(subDept => {
        result[dept.name][subDept] = {};
        [...fullTimePositions, ...partTimePositions, ...otherPositions].forEach(pos => {
          result[dept.name][subDept][pos] = [];
        });
      });
    } else {
      result[dept.name] = {};
      [...fullTimePositions, ...partTimePositions, ...otherPositions].forEach(pos => {
        result[dept.name][pos] = [];
      });
    }
  });
  
  // 기타 카테고리도 초기화
  result['기타'] = {};
  [...fullTimePositions, ...partTimePositions, ...otherPositions].forEach(pos => {
    result['기타'][pos] = [];
  });
  
  // 데이터 처리 (헤더 행 제외)
  let processedCount = 0;
  let activeCount = 0;
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const college = row[colIndex.college] ? row[colIndex.college].toString().trim() : '';
    const dept = row[colIndex.dept] ? row[colIndex.dept].toString().trim() : '';
    const name = row[colIndex.name] ? row[colIndex.name].toString().trim() : '';
    const serialType = row[colIndex.serialType] ? row[colIndex.serialType].toString().trim() : '';
    const originalPosition = row[colIndex.position] ? row[colIndex.position].toString().trim() : '';
    const status = row[colIndex.status] ? row[colIndex.status].toString().trim() : '';
    const salaryStep = colIndex.salary >= 0 && row[colIndex.salary] ? row[colIndex.salary].toString().trim() : '';
    
    // 추가 정보
    const gender = row[colIndex.gender] ? row[colIndex.gender].toString().trim() : '';
    const birthDate = row[colIndex.birthDate] ? formatDate(row[colIndex.birthDate]) : '';
    const firstAppointmentStart = row[colIndex.firstAppointmentStart] ? formatDate(row[colIndex.firstAppointmentStart]) : '';
    const firstAppointmentEnd = row[colIndex.firstAppointmentEnd] ? formatDate(row[colIndex.firstAppointmentEnd]) : '';
    const reappointmentEnd = row[colIndex.reappointmentEnd] ? formatDate(row[colIndex.reappointmentEnd]) : '';
    const retirementDate = colIndex.retirementDate >= 0 && row[colIndex.retirementDate] ? formatDate(row[colIndex.retirementDate]) : '';
    
    // 재직 상태 체크 (재직, 연구년, 휴직 등 포함)
    const isActive = status && (status.includes('재직') || status.includes('연구년') || status.includes('휴직') || status === ' 재직');
    
    if (isActive && name) {
      activeCount++;
      const mappedPosition = positionMapping[originalPosition];
      
      // 이름 정보 객체 생성
      let nameInfo = {
        name: name,
        status: '',
        isSalary: false,
        gender: gender,
        birthDate: birthDate,
        firstAppointmentStart: row[colIndex.firstAppointmentStart] ? formatDate(row[colIndex.firstAppointmentStart]) : '',
        firstAppointmentEnd: firstAppointmentEnd,
        reappointmentEnd: reappointmentEnd,
        retirementDate: retirementDate,
        isRetirementGuaranteed: false,
        position: originalPosition,
        dept: dept,
        college: college,
        serialType: serialType
      };
      
      // 정년 보장 여부 확인 (재임용종료일과 정년일자가 같고, 명예교수가 아닌 경우)
      if (reappointmentEnd && retirementDate && reappointmentEnd === retirementDate && originalPosition !== '명예교수') {
        nameInfo.isRetirementGuaranteed = true;
      }
      
      // 전임교원이고 호봉 데이터가 없으면 연봉제
      if (serialType === '전임교원' && !salaryStep) {
        nameInfo.isSalary = true;
      }
      
      // 재직 상태에 따른 표시 설정
      if (status.includes('휴직')) {
        nameInfo.status = '휴직';
      } else if (status.includes('연구년')) {
        nameInfo.status = '연구';
      }
      
      // 조교가 아닌 기타 직렬 처리
      if (!mappedPosition && serialType !== '조교' && originalPosition !== '행정조교') {
        // 기타 직급 매핑 확인
        const mappedOtherPosition = otherPositionMapping[originalPosition] || otherPositionMapping[serialType];
        
        // 실제 데이터에 있는 특별 부서 목록
        const specialDepts = ['평가성과분석센터', '산학협력단', '용오름대학', '교육혁신원', '박물관', 
                            '체육지원실', '교수학습지원센터', '스포츠.웰니스연구센터', '특수체육연구소',
                            '무도연구소', '혁신사업추진단', '학생생활상담센터', '취창업지원센터', '인권센터'];
        
        let processed = false;
        const targetPosition = mappedOtherPosition || '기타';
        
        // 1. 대학 컬럼이 특별 부서와 정확히 일치하는 경우 우선 처리
        if (specialDepts.includes(college) && result[college]) {
          if (result[college][targetPosition]) {
            result[college][targetPosition].push(nameInfo);
          }
          processedCount++;
          processed = true;
        }
        // 2. 소속 컬럼이 특별 부서와 정확히 일치하는 경우
        else if (!processed && specialDepts.includes(dept) && result[dept]) {
          if (result[dept][targetPosition]) {
            result[dept][targetPosition].push(nameInfo);
          }
          processedCount++;
          processed = true;
        }
        // 3. 소속이 특수체육연구소인 경우 특별 처리
        else if (!processed && dept === '특수체육연구소' && result['특수체육연구소']) {
          if (result['특수체육연구소'][targetPosition]) {
            result['특수체육연구소'][targetPosition].push(nameInfo);
          }
          processedCount++;
          processed = true;
        }
        // 4. 대학원 처리
        else if (!processed && deptStructure[0].subDepts.includes(college)) {
          if (result['대학원'][college] && result['대학원'][college][targetPosition]) {
            result['대학원'][college][targetPosition].push(nameInfo);
            processedCount++;
            processed = true;
          }
        }
        // 5. 일반 대학의 학과 처리
        else if (!processed && result[college] && dept && result[college][dept]) {
          // 이름이 여러 개인 경우 분리
          const names = name.split(/[,，\s]+/).filter(n => n.trim() && n.length >= 2);
          if (names.length > 1) {
            names.forEach(n => {
              const individualNameInfo = Object.assign({}, nameInfo, { name: n.trim() });
              if (result[college][dept][targetPosition]) {
                result[college][dept][targetPosition].push(individualNameInfo);
              }
            });
            processedCount += names.length;
          } else {
            if (result[college][dept][targetPosition]) {
              result[college][dept][targetPosition].push(nameInfo);
            }
            processedCount++;
          }
          processed = true;
        }
        // 6. 그래도 매칭되지 않으면 기타로 처리
        else if (!processed && result['기타'] && result['기타'][targetPosition]) {
          nameInfo.displayName = `${name}(${originalPosition || serialType}, ${dept || college})`;
          // 이름이 여러 개인 경우 분리
          const names = name.split(/[,，\s]+/).filter(n => n.trim() && n.length >= 2);
          if (names.length > 1) {
            names.forEach(n => {
              const individualNameInfo = Object.assign({}, nameInfo, { 
                name: n.trim(),
                displayName: `${n.trim()}(${originalPosition || serialType}, ${dept || college})`
              });
              result['기타'][targetPosition].push(individualNameInfo);
            });
            processedCount += names.length;
          } else {
            result['기타'][targetPosition].push(nameInfo);
            processedCount++;
          }
        }
      }
      // 일반 교원 처리
      else if (mappedPosition) {
        // 실제 데이터에 있는 특별 부서 목록
        const specialDepts = ['평가성과분석센터', '산학협력단', '용오름대학', '교육혁신원', '박물관', 
                            '체육지원실', '교수학습지원센터', '스포츠.웰니스연구센터', '특수체육연구소',
                            '무도연구소', '혁신사업추진단', '학생생활상담센터', '취창업지원센터', '인권센터'];
        
        let processed = false;
        
        // 1. 대학 컬럼이 특별 부서와 정확히 일치하는 경우 우선 처리
        if (specialDepts.includes(college) && result[college] && result[college][mappedPosition]) {
          result[college][mappedPosition].push(nameInfo);
          processedCount++;
          processed = true;
        }
        // 2. 소속 컬럼이 특별 부서와 정확히 일치하는 경우
        else if (!processed && specialDepts.includes(dept) && result[dept] && result[dept][mappedPosition]) {
          result[dept][mappedPosition].push(nameInfo);
          processedCount++;
          processed = true;
        }
        // 3. 소속이 특수체육연구소인 경우 특별 처리
        else if (!processed && dept === '특수체육연구소' && result['특수체육연구소'] && result['특수체육연구소'][mappedPosition]) {
          result['특수체육연구소'][mappedPosition].push(nameInfo);
          processedCount++;
          processed = true;
        }
        // 4. 대학원 처리
        else if (!processed && deptStructure[0].subDepts.includes(college)) {
          if (result['대학원'][college] && result['대학원'][college][mappedPosition]) {
            // 이름이 여러 개인 경우 분리
            const names = name.split(/[,，\s]+/).filter(n => n.trim() && n.length >= 2);
            if (names.length > 1) {
              names.forEach(n => {
                const individualNameInfo = Object.assign({}, nameInfo, { name: n.trim() });
                result['대학원'][college][mappedPosition].push(individualNameInfo);
              });
              processedCount += names.length;
            } else {
              result['대학원'][college][mappedPosition].push(nameInfo);
              processedCount++;
            }
            processed = true;
          }
        }
        // 5. 일반 대학의 학과 처리
        else if (!processed && result[college] && dept && result[college][dept] && result[college][dept][mappedPosition]) {
          // 이름이 여러 개인 경우 분리
          const names = name.split(/[,，\s]+/).filter(n => n.trim() && n.length >= 2);
          if (names.length > 1) {
            names.forEach(n => {
              const individualNameInfo = Object.assign({}, nameInfo, { name: n.trim() });
              result[college][dept][mappedPosition].push(individualNameInfo);
            });
            processedCount += names.length;
          } else {
            result[college][dept][mappedPosition].push(nameInfo);
            processedCount++;
          }
          processed = true;
        }
        // 6. 그래도 매칭되지 않으면 기타로 처리
        else if (!processed && result['기타'] && result['기타'][mappedPosition]) {
          nameInfo.displayName = `${name}(${dept || college})`;
          result['기타'][mappedPosition].push(nameInfo);
          processedCount++;
        }
      }
    }
  }
  
  console.log('활성 상태 인원:', activeCount);
  console.log('처리된 인원:', processedCount);
  
  return {
    facultyData: result,
    deptStructure: deptStructure,
    fullTimePositions: fullTimePositions,
    partTimePositions: partTimePositions,
    otherPositions: otherPositions
  };
}

// 날짜 포맷팅 함수
function formatDate(dateValue) {
  if (!dateValue) return '';
  
  try {
    // 이미 Date 객체인 경우
    if (dateValue instanceof Date) {
      return Utilities.formatDate(dateValue, 'GMT+9', 'yyyy-MM-dd');
    }
    
    // 문자열인 경우
    const dateStr = dateValue.toString();
    
    // 이미 yyyy-MM-dd 형식인 경우
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      return dateStr;
    }
    
    // Excel 시리얼 넘버인 경우
    if (!isNaN(dateStr)) {
      const excelDate = new Date((Number(dateStr) - 25569) * 86400 * 1000);
      return Utilities.formatDate(excelDate, 'GMT+9', 'yyyy-MM-dd');
    }
    
    // 다른 형식의 날짜 문자열인 경우
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return Utilities.formatDate(date, 'GMT+9', 'yyyy-MM-dd');
    }
    
    return dateStr;
  } catch (error) {
    console.error('Date formatting error:', error);
    return '';
  }
}

// 현재 스프레드시트 목록 가져오기 (설정용)
function getSpreadsheets() {
  try {
    const files = DriveApp.getFilesByType(MimeType.GOOGLE_SHEETS);
    const spreadsheets = [];
    
    while (files.hasNext()) {
      const file = files.next();
      spreadsheets.push({
        id: file.getId(),
        name: file.getName()
      });
    }
    
    return spreadsheets;
  } catch (error) {
    return [];
  }
}
