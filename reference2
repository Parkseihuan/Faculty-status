// ì‹œíŠ¸ê°€ ì—´ë¦´ ë•Œë§ˆë‹¤ ì»¤ìŠ¤í…€ ë©”ë‰´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('ì—…ë¬´ ìë™í™”')
    .addItem('1. í—¤ë” ì¶”ì¶œí•˜ì—¬ ë³´ê¸°', 'extractAndShowHeaders')
    .addSeparator()
    .addItem('2. ë°ì´í„° ìë™ ì •ë¦¬í•˜ê¸°', 'cleanData')
    .addSeparator()
    .addItem('3. ì‹œíŠ¸ ë³µì œ ë° ì—´ ì‚­ì œ', 'duplicateAndCleanColumns')
    .addSeparator()
    .addItem('4. ì‹œíŠ¸ ë³€ê²½ì‚¬í•­ ë¹„êµ', 'compareSheets')
    .addToUi();
}

/**
 * 2. ì‹œíŠ¸ì˜ ë¶ˆí•„ìš”í•œ ë¶€ë¶„ì„ ìë™ìœ¼ë¡œ ì •ë¦¬í•˜ëŠ” ë©”ì¸ í•¨ìˆ˜
 */
function cleanData() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  
  let headerRow = findHeaderRowHeuristically(sheet);
  
  if (headerRow === -1) {
    SpreadsheetApp.getUi().alert('í—¤ë”ë¡œ ì¶”ì •ë˜ëŠ” í–‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‹œíŠ¸ ìƒë‹¨ 20ì¤„ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
    return;
  }
  
  consolidateMergedHeaders(sheet, headerRow);
  
  if (headerRow > 1) {
    sheet.deleteRows(1, headerRow - 1);
  }
  
  removeEmptyRowsAtBottom(sheet);
  
  SpreadsheetApp.getUi().alert('ë°ì´í„° ì •ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë³‘í•©ëœ í—¤ë”ê°€ 1í–‰ìœ¼ë¡œ ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
}

/**
 * 1. ì¶”ì¶œëœ í—¤ë”ê°€ ë¬´ì—‡ì¸ì§€ ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜
 */
function extractAndShowHeaders() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const ui = SpreadsheetApp.getUi();

  const headerRowIndex = findHeaderRowHeuristically(sheet);

  if (headerRowIndex === -1) {
    ui.alert('í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }
  
  const consolidatedHeaders = getConsolidatedHeaders(sheet, headerRowIndex);
  const nonEmptyHeaders = consolidatedHeaders.filter(h => h.toString().trim() !== '');

  ui.alert(`ìë™ìœ¼ë¡œ ì¸ì‹ëœ í—¤ë” í–‰ì€ ${headerRowIndex}ë²ˆì§¸ í–‰ì…ë‹ˆë‹¤.\n\ní†µí•©ëœ í—¤ë” ë‚´ìš©:\n${nonEmptyHeaders.join(', ')}`);
}

/**
 * 3. êµì›í˜„í™© ì‹œíŠ¸ë¥¼ ë³µì œí•˜ê³  íŠ¹ì • ì—´ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜ (ìˆ˜ì •ë¨)
 */
function duplicateAndCleanColumns() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = spreadsheet.getSheetByName('êµì›í˜„í™©');
  
  if (!sourceSheet) {
    SpreadsheetApp.getUi().alert('êµì›í˜„í™© ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }
  
  const existingSheet = spreadsheet.getSheetByName('êµì›í˜„í™©_ì •ë¦¬ë³¸');
  if (existingSheet) {
    spreadsheet.deleteSheet(existingSheet);
  }
  
  const newSheet = sourceSheet.copyTo(spreadsheet);
  newSheet.setName('êµì›í˜„í™©_ì •ë¦¬ë³¸');
  
  const sourceIndex = sourceSheet.getIndex();
  newSheet.activate();
  spreadsheet.moveActiveSheet(sourceIndex + 1);
  
  const headerRow = findHeaderRowHeuristically(newSheet);
  if (headerRow !== -1) {
    consolidateMergedHeaders(newSheet, headerRow);
    
    if (headerRow > 1) {
      newSheet.deleteRows(1, headerRow - 1);
    }
    
    deleteRetiredRows(newSheet);
    
    const columnsToDelete = [
      'No.',
      'ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸', 
      'ì£¼ì†Œ', 
      'ìš°í¸ë²ˆí˜¸', 
      'ì „í™”', 
      'ì¢…í•©ì •ë³´ì•„ì´ë””', 
      'ì„±ëª…(ì˜ë¬¸)',
      'ì „ì„êµì› í‡´ì§ì¼ì',
      'í‡´ì§ì¼ì'
    ];
    
    deleteColumnsByHeaderName(newSheet, columnsToDelete);
    
    // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤ ì¶”ê°€
    // 1. ëŒ€í•™/ì†Œì† ì»¬ëŸ¼ì´ ëª¨ë‘ ë¹ˆ í–‰ ì‚­ì œ
    deleteRowsWithEmptyCollegeAndDepartment(newSheet);
    
    // 2. ì§ë ¬ì´ ì´ì¥, ê°ë…, ì‹œê°„ê°•ì‚¬ì¸ í–‰ ì‚­ì œ
    deleteSpecificPositionRows(newSheet);
    
    // 3. ì†Œì† ë‚´ìš©ì„ ëŒ€í•™ìœ¼ë¡œ ë³µì‚¬ (í•„ìš”í•œ ê²½ìš°)
    copyDepartmentToCollege(newSheet);
    
    // 4. ê·¼ì†ì—°ìˆ˜ ê³„ì‚° ë° ì¶”ê°€ (ë‘ ê°œì˜ ì—´ë¡œ ìˆ˜ì •)
    addServiceYearsColumns(newSheet);
    
    removeEmptyRowsAtBottom(newSheet);
    
    // ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œëœ í›„ flush ì‹¤í–‰
    SpreadsheetApp.flush();
    
    // 5. ëª¨ë“  ì—´ ë„ˆë¹„ ìë™ ë§ì¶¤
    autoResizeAllColumns(newSheet);
  }
  
  SpreadsheetApp.getUi().alert('êµì›í˜„í™© ì‹œíŠ¸ê°€ ë³µì œë˜ê³  ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.\n- í‡´ì§ì ë°ì´í„° ì‚­ì œ ì™„ë£Œ\n- ë¶ˆí•„ìš”í•œ ì—´ ì‚­ì œ ì™„ë£Œ (ì£¼ë¯¼ë²ˆí˜¸, ì£¼ì†Œ, ì „í™”, í‡´ì§ì¼ì ë“±)\n- ëŒ€í•™/ì†Œì† ë¹ˆ í–‰ ì‚­ì œ ì™„ë£Œ\n- ì´ì¥/ê°ë…/ì‹œê°„ê°•ì‚¬ í–‰ ì‚­ì œ ì™„ë£Œ\n- ì†Œì†â†’ëŒ€í•™ ë³µì‚¬ ì™„ë£Œ (ë…¸ë€ìƒ‰ í‘œì‹œ)\n- ê·¼ì†ì—°ìˆ˜ 2ê°œ ì—´ ì¶”ê°€ ì™„ë£Œ (ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ê¸°ì¤€, ìµœì´ˆì„ìš© ì‹œì‘ì¼ ê¸°ì¤€)\n- ì—´ ë„ˆë¹„ ìë™ ì¡°ì • ì™„ë£Œ\në³µì œëœ ì‹œíŠ¸ëª…: êµì›í˜„í™©_ì •ë¦¬ë³¸');
}

/**
 * ê·¼ì†ì—°ìˆ˜ë¥¼ ê³„ì‚°í•˜ì—¬ ë§¨ ì˜¤ë¥¸ìª½ì— ë‘ ê°œì˜ ì—´ì„ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜ (ìˆ˜ì •ë¨)
 */
function addServiceYearsColumns(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // ë””ë²„ê¹…ì„ ìœ„í•´ í—¤ë” ì •ë³´ ì¶œë ¥
  console.log('í˜„ì¬ í—¤ë”ë“¤:', headers);
  
  // ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ê³¼ ìµœì´ˆì„ìš© ì‹œì‘ì¼ ì»¬ëŸ¼ ì°¾ê¸° (ë” ìœ ì—°í•œ ë§¤ì¹­)
  let fullTimeAppointmentCol = -1;
  let initialAppointmentCol = -1;
  
  for (let i = 0; i < headers.length; i++) {
    const headerText = headers[i].toString().trim().toLowerCase();
    
    // ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ê´€ë ¨ í—¤ë” ì°¾ê¸°
    if ((headerText.includes('ì „ì„êµì›') || headerText.includes('ì „ì„')) && 
        (headerText.includes('ìµœì´ˆì„ìš©ì¼') || headerText.includes('ì„ìš©ì¼'))) {
      fullTimeAppointmentCol = i + 1;
      console.log('ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ì»¬ëŸ¼ ë°œê²¬:', headers[i], 'ìœ„ì¹˜:', fullTimeAppointmentCol);
    }
    // ìµœì´ˆì„ìš© ì‹œì‘ì¼ ê´€ë ¨ í—¤ë” ì°¾ê¸°
    else if (headerText.includes('ìµœì´ˆì„ìš©') && 
             (headerText.includes('ì‹œì‘ì¼') || headerText.includes('ì¼ì'))) {
      initialAppointmentCol = i + 1;
      console.log('ìµœì´ˆì„ìš© ì‹œì‘ì¼ ì»¬ëŸ¼ ë°œê²¬:', headers[i], 'ìœ„ì¹˜:', initialAppointmentCol);
    }
    // ë‹¤ë¥¸ ê°€ëŠ¥í•œ í—¤ë”ëª…ë“¤
    else if (headerText.includes('ì„ìš©ì¼') && !headerText.includes('í‡´ì§')) {
      if (fullTimeAppointmentCol === -1) {
        fullTimeAppointmentCol = i + 1;
        console.log('ì„ìš©ì¼ ì»¬ëŸ¼ ë°œê²¬:', headers[i], 'ìœ„ì¹˜:', fullTimeAppointmentCol);
      }
    }
  }
  
  console.log('ìµœì¢… ì»¬ëŸ¼ ìœ„ì¹˜ - ì „ì„êµì›:', fullTimeAppointmentCol, 'ìµœì´ˆì„ìš©:', initialAppointmentCol);
  
  // ê·¼ì†ì—°ìˆ˜ í—¤ë” 2ê°œ ì¶”ê°€
  const firstNewColumnIndex = sheet.getLastColumn() + 1;
  const secondNewColumnIndex = firstNewColumnIndex + 1;
  
  sheet.getRange(1, firstNewColumnIndex).setValue('ê·¼ì†ì—°ìˆ˜(ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ê¸°ì¤€)');
  sheet.getRange(1, secondNewColumnIndex).setValue('ê·¼ì†ì—°ìˆ˜(ìµœì´ˆì„ìš© ì‹œì‘ì¼)');
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  const today = new Date();
  console.log('ì˜¤ëŠ˜ ë‚ ì§œ:', today);
  
  // ê° í–‰ì— ëŒ€í•´ ê·¼ì†ì—°ìˆ˜ ê³„ì‚°
  for (let row = 2; row <= lastRow; row++) {
    // ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ê¸°ì¤€ ê·¼ì†ì—°ìˆ˜ ê³„ì‚°
    if (fullTimeAppointmentCol !== -1) {
      const fullTimeDate = sheet.getRange(row, fullTimeAppointmentCol).getValue();
      console.log(`í–‰ ${row} ì „ì„êµì› ë‚ ì§œ:`, fullTimeDate, typeof fullTimeDate);
      
      let appointmentDate = null;
      if (fullTimeDate) {
        // ë¬¸ìì—´ì¸ ê²½ìš° Dateë¡œ ë³€í™˜ ì‹œë„
        if (typeof fullTimeDate === 'string') {
          appointmentDate = parseKoreanDate(fullTimeDate);
        } else if (fullTimeDate instanceof Date) {
          appointmentDate = fullTimeDate;
        }
      }
      
      if (appointmentDate) {
        const serviceYears = calculateServiceYears(appointmentDate, today);
        sheet.getRange(row, firstNewColumnIndex).setValue(serviceYears);
        console.log(`í–‰ ${row} ì „ì„êµì› ê¸°ì¤€ ê·¼ì†ì—°ìˆ˜:`, serviceYears);
      } else {
        sheet.getRange(row, firstNewColumnIndex).setValue('');
      }
    } else {
      // ì „ì„êµì› ìµœì´ˆì„ìš©ì¼ ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
      sheet.getRange(row, firstNewColumnIndex).setValue('í•´ë‹¹ ì—†ìŒ');
    }
    
    // ìµœì´ˆì„ìš© ì‹œì‘ì¼ ê¸°ì¤€ ê·¼ì†ì—°ìˆ˜ ê³„ì‚°
    if (initialAppointmentCol !== -1) {
      const initialDate = sheet.getRange(row, initialAppointmentCol).getValue();
      console.log(`í–‰ ${row} ìµœì´ˆì„ìš© ë‚ ì§œ:`, initialDate, typeof initialDate);
      
      let appointmentDate = null;
      if (initialDate) {
        // ë¬¸ìì—´ì¸ ê²½ìš° Dateë¡œ ë³€í™˜ ì‹œë„
        if (typeof initialDate === 'string') {
          appointmentDate = parseKoreanDate(initialDate);
        } else if (initialDate instanceof Date) {
          appointmentDate = initialDate;
        }
      }
      
      if (appointmentDate) {
        const serviceYears = calculateServiceYears(appointmentDate, today);
        sheet.getRange(row, secondNewColumnIndex).setValue(serviceYears);
        console.log(`í–‰ ${row} ìµœì´ˆì„ìš© ì‹œì‘ì¼ ê¸°ì¤€ ê·¼ì†ì—°ìˆ˜:`, serviceYears);
      } else {
        sheet.getRange(row, secondNewColumnIndex).setValue('');
      }
    } else {
      // ìµœì´ˆì„ìš© ì‹œì‘ì¼ ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
      sheet.getRange(row, secondNewColumnIndex).setValue('í•´ë‹¹ ì—†ìŒ');
    }
  }
}

/**
 * í•œêµ­ì–´ ë‚ ì§œ í˜•ì‹ì„ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜
 */
function parseKoreanDate(dateString) {
  if (!dateString) return null;
  
  const str = dateString.toString().trim();
  
  // YYYY.MM.DD í˜•ì‹
  let match = str.match(/(\d{4})\.(\d{1,2})\.(\d{1,2})/);
  if (match) {
    return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
  }
  
  // YYYY-MM-DD í˜•ì‹
  match = str.match(/(\d{4})-(\d{1,2})-(\d{1,2})/);
  if (match) {
    return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
  }
  
  // YYYY/MM/DD í˜•ì‹
  match = str.match(/(\d{4})\/(\d{1,2})\/(\d{1,2})/);
  if (match) {
    return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
  }
  
  // Date ê°ì²´ë¡œ ë³€í™˜ ì‹œë„
  try {
    const date = new Date(str);
    if (!isNaN(date.getTime())) {
      return date;
    }
  } catch (e) {
    console.log('ë‚ ì§œ íŒŒì‹± ì‹¤íŒ¨:', str);
  }
  
  return null;
}

/**
 * ë‘ ë‚ ì§œ ì‚¬ì´ì˜ ê·¼ì†ì—°ìˆ˜ë¥¼ "?ë…„ ?ê°œì›”" í˜•íƒœë¡œ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
 */
function calculateServiceYears(startDate, endDate) {
  if (!startDate || !endDate) return '';
  
  let years = endDate.getFullYear() - startDate.getFullYear();
  let months = endDate.getMonth() - startDate.getMonth();
  
  // ì›”ì´ ìŒìˆ˜ì¸ ê²½ìš° ì—°ë„ì—ì„œ 1ì„ ë¹¼ê³  ì›”ì— 12ë¥¼ ë”í•¨
  if (months < 0) {
    years--;
    months += 12;
  }
  
  // ì¼ìë¥¼ ê³ ë ¤í•œ ë³´ì •
  if (endDate.getDate() < startDate.getDate()) {
    months--;
    if (months < 0) {
      years--;
      months += 12;
    }
  }
  
  // ê²°ê³¼ í¬ë§·íŒ…
  let result = '';
  if (years > 0) {
    result += years + 'ë…„';
  }
  if (months > 0) {
    result += (result ? ' ' : '') + months + 'ê°œì›”';
  }
  
  // 0ë…„ 0ê°œì›”ì¸ ê²½ìš°
  if (!result) {
    result = '0ê°œì›”';
  }
  
  return result;
}

/**
 * ëª¨ë“  ì—´ì˜ ë„ˆë¹„ë¥¼ ìë™ìœ¼ë¡œ ë§ì¶”ëŠ” í•¨ìˆ˜
 */
function autoResizeAllColumns(sheet) {
  const lastColumn = sheet.getLastColumn();
  const lastRow = sheet.getLastRow();
  
  if (lastColumn > 0 && lastRow > 0) {
    // ì‹œíŠ¸ë¥¼ í™œì„±í™”
    sheet.activate();
    SpreadsheetApp.flush();
    
    // í—¤ë” ê°€ì ¸ì˜¤ê¸°
    const headers = sheet.getRange(1, 1, 1, lastColumn).getValues()[0];
    
    // ê° ì—´ì— ëŒ€í•´ ì²˜ë¦¬
    for (let col = 1; col <= lastColumn; col++) {
      const headerName = headers[col - 1];
      
      try {
        // ë¨¼ì € ê¸°ë³¸ ìë™ ì¡°ì • ì‹œë„
        sheet.autoResizeColumn(col);
        
        // í˜„ì¬ ë„ˆë¹„ í™•ì¸
        let currentWidth = sheet.getColumnWidth(col);
        
        // íŠ¹ì • ì—´ì— ëŒ€í•œ ìµœì†Œ ë„ˆë¹„ ì„¤ì •
        if (headerName === 'ëŒ€í•™' || headerName === 'ì†Œì†') {
          // ëŒ€í•™, ì†Œì† ì—´ì€ ìµœì†Œ 150í”½ì…€
          if (currentWidth < 150) {
            sheet.setColumnWidth(col, 150);
          }
        } else if (headerName === 'ì„±ëª…' || headerName === 'ì„±ëª…(í•œê¸€)') {
          // ì„±ëª… ì—´ì€ ìµœì†Œ 100í”½ì…€
          if (currentWidth < 100) {
            sheet.setColumnWidth(col, 100);
          }
        } else if (headerName === 'ë¹„ê³ ') {
          // ë¹„ê³  ì—´ì€ ìµœì†Œ 200í”½ì…€
          if (currentWidth < 200) {
            sheet.setColumnWidth(col, 200);
          }
        } else if (headerName.includes('ê·¼ì†ì—°ìˆ˜')) {
          // ê·¼ì†ì—°ìˆ˜ ì—´ë“¤ì€ ìµœì†Œ 180í”½ì…€
          if (currentWidth < 180) {
            sheet.setColumnWidth(col, 180);
          }
        }
        
        // ê·¸ë˜ë„ ë„ˆë¹„ê°€ ë„ˆë¬´ ì¢ìœ¼ë©´ ë‚´ìš© ê¸°ë°˜ìœ¼ë¡œ ì¡°ì •
        currentWidth = sheet.getColumnWidth(col);
        if (currentWidth < 80) {
          // í•´ë‹¹ ì—´ì˜ ìµœëŒ€ ë¬¸ì ê¸¸ì´ í™•ì¸
          const columnData = sheet.getRange(1, col, lastRow, 1).getValues();
          let maxLength = 0;
          
          for (let row = 0; row < columnData.length; row++) {
            if (columnData[row][0]) {
              const cellText = columnData[row][0].toString();
              // í•œê¸€ì€ 2, ì˜ë¬¸/ìˆ«ìëŠ” 1ë¡œ ê³„ì‚°
              let cellLength = 0;
              for (let char of cellText) {
                if (char.match(/[ê°€-í£]/)) {
                  cellLength += 2;
                } else {
                  cellLength += 1;
                }
              }
              maxLength = Math.max(maxLength, cellLength);
            }
          }
          
          // ê³„ì‚°ëœ ë„ˆë¹„ ì ìš© (ìµœì†Œ 100í”½ì…€)
          const calculatedWidth = Math.max(100, maxLength * 8 + 20);
          sheet.setColumnWidth(col, calculatedWidth);
        }
        
      } catch (e) {
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ë„ˆë¹„ ì„¤ì •
        console.log(`Error resizing column ${col}: ${e.toString()}`);
        sheet.setColumnWidth(col, 120);
      }
    }
    
    // ìµœì¢… flush
    SpreadsheetApp.flush();
  }
}

/**
 * ëŒ€í•™ê³¼ ì†Œì† ì»¬ëŸ¼ì´ ëª¨ë‘ ë¹„ì–´ìˆëŠ” í–‰ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
 */
function deleteRowsWithEmptyCollegeAndDepartment(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  let collegeCol = -1;
  let departmentCol = -1;
  
  for (let i = 0; i < headers.length; i++) {
    if (headers[i] === 'ëŒ€í•™') {
      collegeCol = i + 1;
    } else if (headers[i] === 'ì†Œì†') {
      departmentCol = i + 1;
    }
  }
  
  if (collegeCol === -1 || departmentCol === -1) return;
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  const dataRange = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn());
  const allData = dataRange.getValues();
  
  const validRowsData = [];
  for (let i = 0; i < allData.length; i++) {
    const collegeValue = allData[i][collegeCol - 1];
    const departmentValue = allData[i][departmentCol - 1];
    
    // ëŒ€í•™ê³¼ ì†Œì† ì¤‘ í•˜ë‚˜ë¼ë„ ê°’ì´ ìˆìœ¼ë©´ ìœ ì§€
    if ((collegeValue && collegeValue.toString().trim() !== '') || 
        (departmentValue && departmentValue.toString().trim() !== '')) {
      validRowsData.push(allData[i]);
    }
  }
  
  if (lastRow > 1) {
    dataRange.clearContent();
  }
  
  if (validRowsData.length > 0) {
    const newRange = sheet.getRange(2, 1, validRowsData.length, validRowsData[0].length);
    newRange.setValues(validRowsData);
  }
  
  const currentLastRow = sheet.getLastRow();
  const newLastRow = validRowsData.length + 1;
  
  if (currentLastRow > newLastRow) {
    sheet.deleteRows(newLastRow + 1, currentLastRow - newLastRow);
  }
}

/**
 * ì§ë ¬ì´ ì´ì¥, ê°ë…, ì‹œê°„ê°•ì‚¬ì¸ í–‰ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
 */
function deleteSpecificPositionRows(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  let positionCol = -1;
  for (let i = 0; i < headers.length; i++) {
    if (headers[i] === 'ì§ë ¬') {
      positionCol = i + 1;
      break;
    }
  }
  
  if (positionCol === -1) return;
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  const dataRange = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn());
  const allData = dataRange.getValues();
  
  // ì‚­ì œí•  ì§ë ¬ ëª©ë¡
  const positionsToDelete = ['ì´ì¥', 'ê°ë…', 'ì‹œê°„ê°•ì‚¬'];
  
  const filteredRowsData = [];
  for (let i = 0; i < allData.length; i++) {
    const positionValue = allData[i][positionCol - 1];
    const positionStr = positionValue ? positionValue.toString().trim() : '';
    
    // ì‚­ì œ ëŒ€ìƒ ì§ë ¬ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ìœ ì§€
    if (!positionsToDelete.includes(positionStr)) {
      filteredRowsData.push(allData[i]);
    }
  }
  
  if (lastRow > 1) {
    dataRange.clearContent();
  }
  
  if (filteredRowsData.length > 0) {
    const newRange = sheet.getRange(2, 1, filteredRowsData.length, filteredRowsData[0].length);
    newRange.setValues(filteredRowsData);
  }
  
  const currentLastRow = sheet.getLastRow();
  const newLastRow = filteredRowsData.length + 1;
  
  if (currentLastRow > newLastRow) {
    sheet.deleteRows(newLastRow + 1, currentLastRow - newLastRow);
  }
}

/**
 * ì†Œì† ì»¬ëŸ¼ì˜ ë‚´ìš©ì„ ëŒ€í•™ ì»¬ëŸ¼ìœ¼ë¡œ ë³µì‚¬í•˜ëŠ” í•¨ìˆ˜
 */
function copyDepartmentToCollege(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  let collegeCol = -1;
  let departmentCol = -1;
  
  for (let i = 0; i < headers.length; i++) {
    if (headers[i] === 'ëŒ€í•™') {
      collegeCol = i + 1;
    } else if (headers[i] === 'ì†Œì†') {
      departmentCol = i + 1;
    }
  }
  
  if (collegeCol === -1 || departmentCol === -1) return;
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  for (let row = 2; row <= lastRow; row++) {
    const collegeValue = sheet.getRange(row, collegeCol).getValue();
    const departmentValue = sheet.getRange(row, departmentCol).getValue();
    
    // ëŒ€í•™ì´ ë¹„ì–´ìˆê³  ì†Œì†ì— ê°’ì´ ìˆëŠ” ê²½ìš°
    if ((!collegeValue || collegeValue.toString().trim() === '') && 
        departmentValue && departmentValue.toString().trim() !== '') {
      
      // ì†Œì† ê°’ì„ ê·¸ëŒ€ë¡œ ëŒ€í•™ ì»¬ëŸ¼ì— ë³µì‚¬
      const targetCell = sheet.getRange(row, collegeCol);
      targetCell.setValue(departmentValue.toString().trim());
      
      // ë…¸ë€ìƒ‰ìœ¼ë¡œ ë°°ê²½ìƒ‰ ë³€ê²½
      targetCell.setBackground('#FFFF00');
    }
  }
}

/**
 * í—¤ë”ëª…ì„ ê¸°ì¤€ìœ¼ë¡œ íŠ¹ì • ì—´ë“¤ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
 */
function deleteColumnsByHeaderName(sheet, headerNames) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const columnsToDelete = [];
  
  for (let i = 0; i < headers.length; i++) {
    const headerText = headers[i].toString().trim();
    if (headerNames.includes(headerText)) {
      columnsToDelete.push(i + 1);
    }
  }
  
  if (columnsToDelete.length === 0) return;
  
  columnsToDelete.sort((a, b) => b - a);
  for (const colIndex of columnsToDelete) {
    sheet.deleteColumn(colIndex);
  }
}

/**
 * ì¬ì§êµ¬ë¶„ì´ 'í‡´ì§'ì¸ í–‰ë“¤ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
 */
function deleteRetiredRows(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  let statusCol = -1;
  for (let i = 0; i < headers.length; i++) {
    if (headers[i] === 'ì¬ì§êµ¬ë¶„') {
      statusCol = i + 1;
      break;
    }
  }
  
  if (statusCol === -1) return;
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  const dataRange = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn());
  const allData = dataRange.getValues();
  
  const activeRowsData = [];
  for (let i = 0; i < allData.length; i++) {
    const statusValue = allData[i][statusCol - 1];
    if (!statusValue || statusValue.toString().trim() !== 'í‡´ì§') {
      activeRowsData.push(allData[i]);
    }
  }
  
  if (lastRow > 1) {
    dataRange.clearContent();
  }
  
  if (activeRowsData.length > 0) {
    const newRange = sheet.getRange(2, 1, activeRowsData.length, activeRowsData[0].length);
    newRange.setValues(activeRowsData);
  }
  
  const currentLastRow = sheet.getLastRow();
  const newLastRow = activeRowsData.length + 1;
  
  if (currentLastRow > newLastRow) {
    sheet.deleteRows(newLastRow + 1, currentLastRow - newLastRow);
  }
}

/**
 * ë³‘í•©ëœ í—¤ë”ë¥¼ ë‹¨ì¼ í–‰ìœ¼ë¡œ ì •ë¦¬í•˜ëŠ” í•¨ìˆ˜
 */
function consolidateMergedHeaders(sheet, headerRowIndex) {
  const maxCols = sheet.getLastColumn();
  const checkRows = Math.min(3, sheet.getMaxRows() - headerRowIndex + 1);
  const headerData = sheet.getRange(headerRowIndex, 1, checkRows, maxCols).getValues();
  
  function isDataRow(rowData) {
    let numericCount = 0;
    let filledCount = 0;
    
    for (let cell of rowData) {
      if (cell && cell.toString().trim() !== '') {
        filledCount++;
        if (!isNaN(cell) || cell.toString().match(/^\d{4}\.\d{1,2}\.\d{1,2}$/)) {
          numericCount++;
        }
      }
    }
    return filledCount > 0 && (numericCount / filledCount) >= 0.3;
  }
  
  let actualHeaderRows = 1;
  if (headerData.length > 1 && !isDataRow(headerData[1])) {
    actualHeaderRows = 2;
  }
  
  const consolidatedHeaders = [];
  
  for (let col = 0; col < maxCols; col++) {
    let headerText = '';
    const primaryHeader = headerData[0][col] ? headerData[0][col].toString().trim() : '';
    let secondaryHeader = '';
    
    if (actualHeaderRows > 1 && headerData[1]) {
      secondaryHeader = headerData[1][col] ? headerData[1][col].toString().trim() : '';
    }
    
    if (primaryHeader) {
      headerText = primaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
      if (secondaryHeader && secondaryHeader !== primaryHeader) {
        const cleanSecondaryHeader = secondaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
        headerText = `${headerText}_${cleanSecondaryHeader}`;
      }
    } else if (secondaryHeader) {
      headerText = secondaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    }
    
    consolidatedHeaders.push(headerText);
  }
  
  if (consolidatedHeaders.length > 0) {
    sheet.getRange(headerRowIndex, 1, 1, consolidatedHeaders.length).setValues([consolidatedHeaders]);
    if (actualHeaderRows > 1) {
      sheet.deleteRow(headerRowIndex + 1);
    }
  }
  
  try {
    sheet.getRange(headerRowIndex, 1, 1, maxCols).breakApart();
  } catch (e) {
    // ë³‘í•©ëœ ì…€ì´ ì—†ëŠ” ê²½ìš° ë¬´ì‹œ
  }
}

/**
 * ë³‘í•©ëœ í—¤ë”ë¥¼ ê³ ë ¤í•˜ì—¬ í†µí•©ëœ í—¤ë” í…ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
 */
function getConsolidatedHeaders(sheet, headerRowIndex) {
  const maxCols = sheet.getLastColumn();
  const checkRows = Math.min(3, sheet.getMaxRows() - headerRowIndex + 1);
  const headerData = sheet.getRange(headerRowIndex, 1, checkRows, maxCols).getValues();
  
  function isDataRow(rowData) {
    let numericCount = 0;
    let filledCount = 0;
    
    for (let cell of rowData) {
      if (cell && cell.toString().trim() !== '') {
        filledCount++;
        if (!isNaN(cell) || cell.toString().match(/^\d{4}\.\d{1,2}\.\d{1,2}$/)) {
          numericCount++;
        }
      }
    }
    return filledCount > 0 && (numericCount / filledCount) >= 0.3;
  }
  
  let actualHeaderRows = 1;
  if (headerData.length > 1 && !isDataRow(headerData[1])) {
    actualHeaderRows = 2;
  }
  
  const consolidatedHeaders = [];
  
  for (let col = 0; col < maxCols; col++) {
    let headerText = '';
    const primaryHeader = headerData[0][col] ? headerData[0][col].toString().trim() : '';
    let secondaryHeader = '';
    
    if (actualHeaderRows > 1 && headerData[1]) {
      secondaryHeader = headerData[1][col] ? headerData[1][col].toString().trim() : '';
    }
    
    if (primaryHeader) {
      headerText = primaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
      if (secondaryHeader && secondaryHeader !== primaryHeader) {
        const cleanSecondaryHeader = secondaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
        headerText = `${headerText}_${cleanSecondaryHeader}`;
      }
    } else if (secondaryHeader) {
      headerText = secondaryHeader.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    }
    
    consolidatedHeaders.push(headerText);
  }
  
  return consolidatedHeaders;
}

/**
 * ê²½í—˜ì  ê·œì¹™ìœ¼ë¡œ í—¤ë” í–‰ì„ ì°¾ëŠ” í•¨ìˆ˜
 */
function findHeaderRowHeuristically(sheet) {
  const maxRowsToCheck = 20;
  const data = sheet.getRange(1, 1, maxRowsToCheck, sheet.getLastColumn()).getValues();
  
  let bestCandidateRow = -1;
  let maxFilledCells = 0;

  for (let i = 0; i < data.length; i++) {
    const filledCells = data[i].filter(cell => cell.toString().trim() !== '').length;
    
    if (filledCells >= 3 && filledCells > maxFilledCells) {
      maxFilledCells = filledCells;
      bestCandidateRow = i + 1;
    }
  }
  return bestCandidateRow;
}

/**
 * ì‹œíŠ¸ í•˜ë‹¨ì˜ ë¹ˆ í–‰ë“¤ì„ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
 */
function removeEmptyRowsAtBottom(sheet) {
  const maxRows = sheet.getMaxRows();
  const lastRow = sheet.getLastRow();
  
  if (maxRows > lastRow) {
    sheet.deleteRows(lastRow + 1, maxRows - lastRow);
  }
}

/**
 * 4. ë‘ ì‹œíŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ë³€ê²½ì‚¬í•­ì„ ì°¾ëŠ” ë©”ì¸ í•¨ìˆ˜ (ëŒ€í™”ìƒì ë°©ì‹)
 */
function compareSheets() {
  const ui = SpreadsheetApp.getUi();
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  
  try {
    const sheets = spreadsheet.getSheets();
    const sheetNames = sheets.map(s => s.getName());
    
    // ë¹„êµ ëŒ€ìƒ ì‹œíŠ¸ ì œì™¸ ëª©ë¡
    const excludeSheets = ['ë³€ê²½ì‚¬í•­_ë¹„êµê²°ê³¼', 'êµì›í˜„í™©_ì •ë¦¬ë³¸'];
    const availableSheets = sheetNames.filter(name => !excludeSheets.includes(name));
    
    if (availableSheets.length < 2) {
      ui.alert('ë¹„êµí•  ìˆ˜ ìˆëŠ” ì‹œíŠ¸ê°€ 2ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.');
      return;
    }
    
    // ê°„ë‹¨í•œ í”„ë¡¬í”„íŠ¸ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    const sheetListText = availableSheets.map((name, index) => `${index + 1}. ${name}`).join('\n');
    
    const oldSheetResponse = ui.prompt(
      'ì´ì „ ë²„ì „ ì‹œíŠ¸ ì„ íƒ',
      `ë¹„êµí•  ì´ì „ ë²„ì „ ì‹œíŠ¸ì˜ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:\n\n${sheetListText}\n\në²ˆí˜¸ ì…ë ¥:`,
      ui.ButtonSet.OK_CANCEL
    );
    
    if (oldSheetResponse.getSelectedButton() !== ui.Button.OK) {
      return;
    }
    
    const oldSheetIndex = parseInt(oldSheetResponse.getResponseText()) - 1;
    if (isNaN(oldSheetIndex) || oldSheetIndex < 0 || oldSheetIndex >= availableSheets.length) {
      ui.alert('ì˜¬ë°”ë¥¸ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    const oldSheetName = availableSheets[oldSheetIndex];
    
    // ì„ íƒëœ ì‹œíŠ¸ë¥¼ ì œì™¸í•œ ëª©ë¡ ìƒì„±
    const remainingSheets = availableSheets.filter((name, index) => index !== oldSheetIndex);
    const remainingListText = remainingSheets.map((name, index) => `${index + 1}. ${name}`).join('\n');
    
    const newSheetResponse = ui.prompt(
      'í˜„ì¬ ë²„ì „ ì‹œíŠ¸ ì„ íƒ',
      `ë¹„êµí•  í˜„ì¬ ë²„ì „ ì‹œíŠ¸ì˜ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:\n\n${remainingListText}\n\në²ˆí˜¸ ì…ë ¥:`,
      ui.ButtonSet.OK_CANCEL
    );
    
    if (newSheetResponse.getSelectedButton() !== ui.Button.OK) {
      return;
    }
    
    const newSheetIndex = parseInt(newSheetResponse.getResponseText()) - 1;
    if (isNaN(newSheetIndex) || newSheetIndex < 0 || newSheetIndex >= remainingSheets.length) {
      ui.alert('ì˜¬ë°”ë¥¸ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    const newSheetName = remainingSheets[newSheetIndex];
    
    // ë¹„êµ ì‹¤í–‰ í™•ì¸
    const confirmResult = ui.alert(
      'ë¹„êµ í™•ì¸',
      `ë‹¤ìŒ ì‹œíŠ¸ë¥¼ ë¹„êµí•©ë‹ˆë‹¤:\n\nì´ì „ ë²„ì „: ${oldSheetName}\ní˜„ì¬ ë²„ì „: ${newSheetName}\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,
      ui.ButtonSet.YES_NO
    );
    
    if (confirmResult !== ui.Button.YES) {
      return;
    }
    
    // ë¹„êµ ì‹¤í–‰
    executeSheetsComparison(oldSheetName, newSheetName);
    
  } catch (error) {
    ui.alert('ì˜¤ë¥˜ ë°œìƒ', 'ì‹œíŠ¸ ë¹„êµ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n' + error.toString(), ui.ButtonSet.OK);
  }
}

/**
 * ì‹¤ì œ ë¹„êµ ì‹¤í–‰ í•¨ìˆ˜
 */
function executeSheetsComparison(oldSheetName, newSheetName) {
  const ui = SpreadsheetApp.getUi();
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  
  try {
    const oldSheet = spreadsheet.getSheetByName(oldSheetName);
    const newSheet = spreadsheet.getSheetByName(newSheetName);
    
    if (!oldSheet || !newSheet) {
      throw new Error('ì„ íƒí•œ ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
    
    // ë¹„êµ ê²°ê³¼ë¥¼ ì €ì¥í•  ìƒˆ ì‹œíŠ¸ ìƒì„±
    const resultSheetName = 'ë³€ê²½ì‚¬í•­_ë¹„êµê²°ê³¼';
    let resultSheet = spreadsheet.getSheetByName(resultSheetName);
    if (resultSheet) {
      spreadsheet.deleteSheet(resultSheet);
    }
    resultSheet = spreadsheet.insertSheet(resultSheetName);
    
    // ë¹„êµ ì‹¤í–‰
    const changes = compareData(oldSheet, newSheet);
    
    // ê²°ê³¼ ì¶œë ¥
    displayComparisonResults(resultSheet, changes, oldSheetName, newSheetName);
    
    // ê²°ê³¼ ì‹œíŠ¸ë¡œ ì´ë™
    resultSheet.activate();
    
    // ì™„ë£Œ ë©”ì‹œì§€
    const totalChanges = changes.added.length + changes.removed.length + changes.modified.length;
    
    ui.alert(
      'ë¹„êµ ì™„ë£Œ',
      `âœ… ë³€ê²½ì‚¬í•­ ë¹„êµê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\n` +
      `ğŸ“Š ì´ ${totalChanges}ê±´ì˜ ë³€ê²½ì‚¬í•­\n` +
      `â€¢ ì‹ ê·œ ì¶”ê°€: ${changes.added.length}ê±´\n` +
      `â€¢ ì‚­ì œ: ${changes.removed.length}ê±´\n` +
      `â€¢ ìˆ˜ì •: ${changes.modified.length}ê±´\n\n` +
      `ìƒì„¸ ë‚´ìš©ì€ '${resultSheetName}' ì‹œíŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`,
      ui.ButtonSet.OK
    );
    
    return true;
    
  } catch (error) {
    throw new Error('ë¹„êµ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: ' + error.toString());
  }
}

/**
 * ë‘ ì‹œíŠ¸ì˜ ë°ì´í„°ë¥¼ ë¹„êµí•˜ëŠ” í•¨ìˆ˜
 */
function compareData(oldSheet, newSheet) {
  // í—¤ë” ì°¾ê¸°
  const oldHeaderRow = findHeaderRowHeuristically(oldSheet);
  const newHeaderRow = findHeaderRowHeuristically(newSheet);
  
  if (oldHeaderRow === -1 || newHeaderRow === -1) {
    throw new Error('í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  }
  
  // ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const oldData = getSheetDataAsObject(oldSheet, oldHeaderRow);
  const newData = getSheetDataAsObject(newSheet, newHeaderRow);
  
  // ê¸°ì¤€ ì—´ ì°¾ê¸° (ì„±ëª… ë˜ëŠ” ì„±ëª…(í•œê¸€))
  const keyColumn = findKeyColumn(oldData.headers);
  
  // ë°ì´í„°ë¥¼ Mapìœ¼ë¡œ ë³€í™˜ (ì„±ëª…ì„ í‚¤ë¡œ ì‚¬ìš©)
  const oldMap = new Map();
  const newMap = new Map();
  
  oldData.rows.forEach(row => {
    const key = row[keyColumn];
    if (key) oldMap.set(key, row);
  });
  
  newData.rows.forEach(row => {
    const key = row[keyColumn];
    if (key) newMap.set(key, row);
  });
  
  // ë³€ê²½ì‚¬í•­ ì°¾ê¸°
  const changes = {
    added: [],      // ì‹ ê·œ ì¶”ê°€ëœ êµì›
    removed: [],    // ì‚­ì œëœ êµì›
    modified: []    // ì •ë³´ê°€ ë³€ê²½ëœ êµì›
  };
  
  // ì‚­ì œëœ í•­ëª© ì°¾ê¸°
  oldMap.forEach((oldRow, key) => {
    if (!newMap.has(key)) {
      changes.removed.push({
        name: key,
        data: oldRow
      });
    }
  });
  
  // ì¶”ê°€ ë° ìˆ˜ì •ëœ í•­ëª© ì°¾ê¸°
  newMap.forEach((newRow, key) => {
    if (!oldMap.has(key)) {
      // ì‹ ê·œ ì¶”ê°€
      changes.added.push({
        name: key,
        data: newRow
      });
    } else {
      // ë³€ê²½ì‚¬í•­ í™•ì¸
      const oldRow = oldMap.get(key);
      const modifications = findModifications(oldRow, newRow, oldData.headers);
      
      if (modifications.length > 0) {
        changes.modified.push({
          name: key,
          modifications: modifications,
          oldData: oldRow,
          newData: newRow
        });
      }
    }
  });
  
  return changes;
}

/**
 * ì‹œíŠ¸ ë°ì´í„°ë¥¼ ê°ì²´ í˜•íƒœë¡œ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
 */
function getSheetDataAsObject(sheet, headerRow) {
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  
  if (lastRow < headerRow) {
    return { headers: [], rows: [] };
  }
  
  // í—¤ë” ê°€ì ¸ì˜¤ê¸°
  const headers = sheet.getRange(headerRow, 1, 1, lastCol).getValues()[0];
  
  // ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const rows = [];
  if (lastRow > headerRow) {
    const dataRange = sheet.getRange(headerRow + 1, 1, lastRow - headerRow, lastCol);
    const dataValues = dataRange.getValues();
    
    dataValues.forEach(row => {
      const rowObj = {};
      headers.forEach((header, index) => {
        rowObj[header] = row[index];
      });
      rows.push(rowObj);
    });
  }
  
  return { headers, rows };
}

/**
 * ê¸°ì¤€ì´ ë˜ëŠ” í‚¤ ì—´ì„ ì°¾ëŠ” í•¨ìˆ˜ (ì„±ëª… ì—´)
 */
function findKeyColumn(headers) {
  // ê°€ëŠ¥í•œ ì„±ëª… ê´€ë ¨ í—¤ë”ë“¤
  const possibleKeys = ['ì„±ëª…', 'ì„±ëª…(í•œê¸€)', 'ì´ë¦„', 'êµì›ëª…'];
  
  for (const key of possibleKeys) {
    if (headers.includes(key)) {
      return key;
    }
  }
  
  // ê¸°ë³¸ê°’ìœ¼ë¡œ ì²« ë²ˆì§¸ í—¤ë” ì‚¬ìš©
  return headers[0];
}

/**
 * ë‘ í–‰ ê°„ì˜ ë³€ê²½ì‚¬í•­ì„ ì°¾ëŠ” í•¨ìˆ˜
 */
function findModifications(oldRow, newRow, headers) {
  const modifications = [];
  
  // ì¤‘ìš”í•œ í•„ë“œë“¤ì„ ìš°ì„  í™•ì¸
  const importantFields = ['ì¬ì§êµ¬ë¶„', 'ì§ê¸‰', 'ì§ë ¬', 'ëŒ€í•™', 'ì†Œì†', 
                          'ì¬ì„ìš©ì‹œì‘ì¼', 'ì¬ì„ìš©ì¢…ë£Œì¼', 'ì „ì„êµì› ìµœì´ˆì„ìš©ì¼', 
                          'ìµœì´ˆì„ìš© ì‹œì‘ì¼', 'í‡´ì§ì¼ì'];
  
  // ì¤‘ìš” í•„ë“œ ë¨¼ì € í™•ì¸
  for (const field of importantFields) {
    if (headers.includes(field)) {
      const oldValue = oldRow[field] || '';
      const newValue = newRow[field] || '';
      
      if (normalizeValue(oldValue) !== normalizeValue(newValue)) {
        modifications.push({
          field: field,
          oldValue: oldValue,
          newValue: newValue,
          isImportant: true
        });
      }
    }
  }
  
  // ë‚˜ë¨¸ì§€ í•„ë“œ í™•ì¸
  for (const header of headers) {
    if (!importantFields.includes(header)) {
      const oldValue = oldRow[header] || '';
      const newValue = newRow[header] || '';
      
      if (normalizeValue(oldValue) !== normalizeValue(newValue)) {
        modifications.push({
          field: header,
          oldValue: oldValue,
          newValue: newValue,
          isImportant: false
        });
      }
    }
  }
  
  return modifications;
}

/**
 * ê°’ì„ ì •ê·œí™”í•˜ëŠ” í•¨ìˆ˜ (ë¹„êµë¥¼ ìœ„í•´)
 */
function normalizeValue(value) {
  if (value instanceof Date) {
    return Utilities.formatDate(value, 'GMT+9', 'yyyy-MM-dd');
  }
  return value.toString().trim();
}

/**
 * ë¹„êµ ê²°ê³¼ë¥¼ ì‹œíŠ¸ì— í‘œì‹œí•˜ëŠ” í•¨ìˆ˜ (ë””ìì¸ ê°œì„  ë²„ì „)
 */
function displayComparisonResults(sheet, changes, oldSheetName, newSheetName) {
  let row = 1;
  
  // ì „ì²´ ë°°ê²½ìƒ‰ ì„¤ì •
  sheet.getRange(1, 1, 200, 10).setBackground('#FFFFFF');
  
  // ===== íƒ€ì´í‹€ ì„¹ì…˜ =====
  sheet.getRange(row, 1).setValue('ğŸ“Š êµì›í˜„í™© ë³€ê²½ì‚¬í•­ ë¹„êµ ë³´ê³ ì„œ');
  sheet.getRange(row, 1).setFontSize(20).setFontWeight('bold').setFontColor('#1a73e8');
  row += 1;
  
  // êµ¬ë¶„ì„ 
  sheet.getRange(row, 1, 1, 8).setBackground('#1a73e8');
  sheet.setRowHeight(row, 3);
  row += 2;
  
  // ===== ë¹„êµ ì •ë³´ ì„¹ì…˜ =====
  // ë¹„êµ ì •ë³´ ì¹´ë“œ ìŠ¤íƒ€ì¼
  sheet.getRange(row, 1, 3, 8).setBorder(true, true, true, true, false, false, '#dadce0', SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange(row, 1, 3, 8).setBackground('#f8f9fa');
  
  sheet.getRange(row, 1).setValue('ğŸ“ ì´ì „ ì‹œíŠ¸');
  sheet.getRange(row, 1).setFontWeight('bold').setFontColor('#5f6368');
  sheet.getRange(row, 2, 1, 2).merge();
  sheet.getRange(row, 2).setValue(oldSheetName);
  sheet.getRange(row, 2).setFontColor('#202124');
  
  sheet.getRange(row, 5).setValue('ğŸ“ í˜„ì¬ ì‹œíŠ¸');
  sheet.getRange(row, 5).setFontWeight('bold').setFontColor('#5f6368');
  sheet.getRange(row, 6, 1, 2).merge();
  sheet.getRange(row, 6).setValue(newSheetName);
  sheet.getRange(row, 6).setFontColor('#202124');
  row += 1;
  
  sheet.getRange(row, 1).setValue('ğŸ• ë¹„êµ ì¼ì‹œ');
  sheet.getRange(row, 1).setFontWeight('bold').setFontColor('#5f6368');
  sheet.getRange(row, 2, 1, 3).merge();
  sheet.getRange(row, 2).setValue(Utilities.formatDate(new Date(), 'GMT+9', 'yyyyë…„ MMì›” ddì¼ HH:mm:ss'));
  sheet.getRange(row, 2).setFontColor('#202124');
  
  sheet.getRange(row, 5).setValue('ğŸ‘¤ ì‘ì„±ì');
  sheet.getRange(row, 5).setFontWeight('bold').setFontColor('#5f6368');
  sheet.getRange(row, 6, 1, 2).merge();
  sheet.getRange(row, 6).setValue(Session.getActiveUser().getEmail());
  sheet.getRange(row, 6).setFontColor('#202124');
  row += 3;
  
  // ===== ìš”ì•½ í†µê³„ ì„¹ì…˜ =====
  const totalChanges = changes.added.length + changes.removed.length + changes.modified.length;
  
  // ìš”ì•½ ì œëª©
  sheet.getRange(row, 1).setValue('ğŸ“ˆ ë³€ê²½ì‚¬í•­ ìš”ì•½');
  sheet.getRange(row, 1).setFontSize(16).setFontWeight('bold').setFontColor('#1a73e8');
  row += 2;
  
  // í†µê³„ ì¹´ë“œë“¤
  // ì „ì²´ ë³€ê²½ê±´ìˆ˜ (í° ì¹´ë“œ)
  sheet.getRange(row, 1, 3, 8).setBorder(true, true, true, true, false, false, '#dadce0', SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange(row, 1, 1, 8).setBackground('#e8f0fe');
  sheet.getRange(row, 1, 1, 2).merge();
  sheet.getRange(row, 1).setValue('ì „ì²´ ë³€ê²½ê±´ìˆ˜');
  sheet.getRange(row, 1).setFontWeight('bold').setFontColor('#1967d2');
  sheet.getRange(row, 3, 1, 2).merge();
  sheet.getRange(row, 3).setValue(totalChanges + 'ê±´');
  sheet.getRange(row, 3).setFontSize(18).setFontWeight('bold').setFontColor('#1967d2');
  sheet.getRange(row, 3).setHorizontalAlignment('center');
  row += 2;
  
  // ê°œë³„ í†µê³„ (3ê°œ ì¹´ë“œ)
  // ì‹ ê·œ ì¶”ê°€ ì¹´ë“œ
  sheet.getRange(row, 1, 2, 2).setBorder(true, true, true, true, false, false, '#34a853', SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange(row, 1, 1, 2).setBackground('#e6f4ea');
  sheet.getRange(row, 1).setValue('âœ… ì‹ ê·œ ì¶”ê°€');
  sheet.getRange(row, 1).setFontWeight('bold').setFontColor('#188038');
  sheet.getRange(row + 1, 1, 1, 2).merge();
  sheet.getRange(row + 1, 1).setValue(changes.added.length + 'ê±´');
  sheet.getRange(row + 1, 1).setFontSize(24).setFontWeight('bold').setFontColor('#188038');
  sheet.getRange(row + 1, 1).setHorizontalAlignment('center');
  
  // ì‚­ì œ ì¹´ë“œ
  sheet.getRange(row, 3, 2, 2).setBorder(true, true, true, true, false, false, '#ea4335', SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange(row, 3, 1, 2).setBackground('#fce8e6');
  sheet.getRange(row, 3).setValue('âŒ ì‚­ì œ');
  sheet.getRange(row, 3).setFontWeight('bold').setFontColor('#c5221f');
  sheet.getRange(row + 1, 3, 1, 2).merge();
  sheet.getRange(row + 1, 3).setValue(changes.removed.length + 'ê±´');
  sheet.getRange(row + 1, 3).setFontSize(24).setFontWeight('bold').setFontColor('#c5221f');
  sheet.getRange(row + 1, 3).setHorizontalAlignment('center');
  
  // ìˆ˜ì • ì¹´ë“œ
  sheet.getRange(row, 5, 2, 2).setBorder(true, true, true, true, false, false, '#fbbc04', SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange(row, 5, 1, 2).setBackground('#fef7e0');
  sheet.getRange(row, 5).setValue('âœï¸ ìˆ˜ì •');
  sheet.getRange(row, 5).setFontWeight('bold').setFontColor('#f9ab00');
  sheet.getRange(row + 1, 5, 1, 2).merge();
  sheet.getRange(row + 1, 5).setValue(changes.modified.length + 'ê±´');
  sheet.getRange(row + 1, 5).setFontSize(24).setFontWeight('bold').setFontColor('#f9ab00');
  sheet.getRange(row + 1, 5).setHorizontalAlignment('center');
  
  row += 4;
  
  // ===== ì‹ ê·œ ì¶”ê°€ëœ êµì› ì„¹ì…˜ =====
  if (changes.added.length > 0) {
    // ì„¹ì…˜ ì œëª©
    sheet.getRange(row, 1, 1, 8).setBackground('#e6f4ea');
    sheet.getRange(row, 1).setValue('âœ… ì‹ ê·œ ì¶”ê°€ëœ êµì› (' + changes.added.length + 'ëª…)');
    sheet.getRange(row, 1).setFontSize(14).setFontWeight('bold').setFontColor('#188038');
    row += 1;
    
    // í…Œì´ë¸” í—¤ë”
    const addedHeaders = [['No.', 'ì„±ëª…', 'ì§ê¸‰', 'ì§ë ¬', 'ëŒ€í•™', 'ì†Œì†', 'ì¬ì§êµ¬ë¶„', 'ë¹„ê³ ']];
    sheet.getRange(row, 1, 1, 8).setValues(addedHeaders);
    sheet.getRange(row, 1, 1, 8).setBackground('#34a853');
    sheet.getRange(row, 1, 1, 8).setFontColor('#ffffff');
    sheet.getRange(row, 1, 1, 8).setFontWeight('bold');
    sheet.getRange(row, 1, 1, 8).setBorder(true, true, true, true, true, true, '#ffffff', SpreadsheetApp.BorderStyle.SOLID);
    row += 1;
    
    // ë°ì´í„° í–‰
    changes.added.forEach((item, index) => {
      const rowData = [[
        index + 1,
        item.name || '',
        item.data['ì§ê¸‰'] || '',
        item.data['ì§ë ¬'] || '',
        item.data['ëŒ€í•™'] || '',
        item.data['ì†Œì†'] || '',
        item.data['ì¬ì§êµ¬ë¶„'] || '',
        ''
      ]];
      sheet.getRange(row, 1, 1, 8).setValues(rowData);
      sheet.getRange(row, 1, 1, 8).setBorder(null, true, true, true, true, true, '#e0e0e0', SpreadsheetApp.BorderStyle.SOLID);
      
      // ì§ìˆ˜ í–‰ ë°°ê²½ìƒ‰
      if (index % 2 === 0) {
        sheet.getRange(row, 1, 1, 8).setBackground('#f8f9fa');
      }
      row += 1;
    });
    row += 2;
  }
  
  // ===== ì‚­ì œëœ êµì› ì„¹ì…˜ =====
  if (changes.removed.length > 0) {
    // ì„¹ì…˜ ì œëª©
    sheet.getRange(row, 1, 1, 8).setBackground('#fce8e6');
    sheet.getRange(row, 1).setValue('âŒ ì‚­ì œëœ êµì› (' + changes.removed.length + 'ëª…)');
    sheet.getRange(row, 1).setFontSize(14).setFontWeight('bold').setFontColor('#c5221f');
    row += 1;
    
    // í…Œì´ë¸” í—¤ë”
    const removedHeaders = [['No.', 'ì„±ëª…', 'ì§ê¸‰', 'ì§ë ¬', 'ëŒ€í•™', 'ì†Œì†', 'ì¬ì§êµ¬ë¶„', 'ë¹„ê³ ']];
    sheet.getRange(row, 1, 1, 8).setValues(removedHeaders);
    sheet.getRange(row, 1, 1, 8).setBackground('#ea4335');
    sheet.getRange(row, 1, 1, 8).setFontColor('#ffffff');
    sheet.getRange(row, 1, 1, 8).setFontWeight('bold');
    sheet.getRange(row, 1, 1, 8).setBorder(true, true, true, true, true, true, '#ffffff', SpreadsheetApp.BorderStyle.SOLID);
    row += 1;
    
    // ë°ì´í„° í–‰
    changes.removed.forEach((item, index) => {
      const rowData = [[
        index + 1,
        item.name || '',
        item.data['ì§ê¸‰'] || '',
        item.data['ì§ë ¬'] || '',
        item.data['ëŒ€í•™'] || '',
        item.data['ì†Œì†'] || '',
        item.data['ì¬ì§êµ¬ë¶„'] || '',
        ''
      ]];
      sheet.getRange(row, 1, 1, 8).setValues(rowData);
      sheet.getRange(row, 1, 1, 8).setBorder(null, true, true, true, true, true, '#e0e0e0', SpreadsheetApp.BorderStyle.SOLID);
      
      // ì§ìˆ˜ í–‰ ë°°ê²½ìƒ‰
      if (index % 2 === 0) {
        sheet.getRange(row, 1, 1, 8).setBackground('#f8f9fa');
      }
      row += 1;
    });
    row += 2;
  }
  
  // ===== ì •ë³´ê°€ ë³€ê²½ëœ êµì› ì„¹ì…˜ =====
  if (changes.modified.length > 0) {
    // ì„¹ì…˜ ì œëª©
    sheet.getRange(row, 1, 1, 8).setBackground('#fef7e0');
    sheet.getRange(row, 1).setValue('âœï¸ ì •ë³´ê°€ ë³€ê²½ëœ êµì› (' + changes.modified.length + 'ëª…)');
    sheet.getRange(row, 1).setFontSize(14).setFontWeight('bold').setFontColor('#f9ab00');
    row += 1;
    
    // í…Œì´ë¸” í—¤ë”
    const modifiedHeaders = [['No.', 'ì„±ëª…', 'ë³€ê²½ í•­ëª©', 'ì´ì „ ê°’', '', 'ë³€ê²½ ê°’', 'ì¤‘ìš”ë„', '']];
    sheet.getRange(row, 1, 1, 8).setValues(modifiedHeaders);
    sheet.getRange(row, 1, 1, 8).setBackground('#fbbc04');
    sheet.getRange(row, 1, 1, 8).setFontColor('#ffffff');
    sheet.getRange(row, 1, 1, 8).setFontWeight('bold');
    sheet.getRange(row, 1, 1, 8).setBorder(true, true, true, true, true, true, '#ffffff', SpreadsheetApp.BorderStyle.SOLID);
    row += 1;
    
    let modIndex = 1;
    changes.modified.forEach(item => {
      const importantMods = item.modifications.filter(m => m.isImportant);
      const otherMods = item.modifications.filter(m => !m.isImportant);
      
      let isFirstRow = true;
      
      // ì¤‘ìš” ë³€ê²½ì‚¬í•­
      importantMods.forEach(mod => {
        const modRowData = [[
          isFirstRow ? modIndex++ : '',
          isFirstRow ? item.name || '' : '',
          mod.field || '',
          formatValue(mod.oldValue),
          'â†’',
          formatValue(mod.newValue),
          'âš ï¸ ì¤‘ìš”',
          ''
        ]];
        sheet.getRange(row, 1, 1, 8).setValues(modRowData);
        sheet.getRange(row, 1, 1, 8).setBorder(null, true, true, true, true, true, '#e0e0e0', SpreadsheetApp.BorderStyle.SOLID);
        
        // ì¤‘ìš” ë³€ê²½ì‚¬í•­ ê°•ì¡°
        sheet.getRange(row, 1, 1, 8).setBackground('#fff4e6');
        sheet.getRange(row, 7).setFontWeight('bold').setFontColor('#e37400');
        
        isFirstRow = false;
        row += 1;
      });
      
      // ê¸°íƒ€ ë³€ê²½ì‚¬í•­ (ìµœëŒ€ 3ê°œ)
      const displayOtherMods = otherMods.slice(0, 3);
      displayOtherMods.forEach(mod => {
        const modRowData = [[
          isFirstRow ? modIndex++ : '',
          isFirstRow ? item.name || '' : '',
          mod.field || '',
          formatValue(mod.oldValue),
          'â†’',
          formatValue(mod.newValue),
          '',
          ''
        ]];
        sheet.getRange(row, 1, 1, 8).setValues(modRowData);
        sheet.getRange(row, 1, 1, 8).setBorder(null, true, true, true, true, true, '#e0e0e0', SpreadsheetApp.BorderStyle.SOLID);
        
        // ì¼ë°˜ í–‰ ë°°ê²½ìƒ‰
        sheet.getRange(row, 1, 1, 8).setBackground('#f8f9fa');
        
        isFirstRow = false;
        row += 1;
      });
      
      // ì¶”ê°€ í•­ëª©ì´ ìˆëŠ” ê²½ìš°
      if (otherMods.length > 3) {
        const extraRowData = [[
          '',
          '',
          '... ê·¸ ì™¸ ' + (otherMods.length - 3) + 'ê°œ í•­ëª© ë³€ê²½',
          '',
          '',
          '',
          '',
          ''
        ]];
        sheet.getRange(row, 1, 1, 8).setValues(extraRowData);
        sheet.getRange(row, 3).setFontStyle('italic').setFontColor('#5f6368');
        sheet.getRange(row, 1, 1, 8).setBorder(null, true, true, true, true, true, '#e0e0e0', SpreadsheetApp.BorderStyle.SOLID);
        sheet.getRange(row, 1, 1, 8).setBackground('#f8f9fa');
        row += 1;
      }
      
      // í•­ëª© ê°„ êµ¬ë¶„ì„ ìœ„í•œ ë¹ˆ í–‰
      if (changes.modified.indexOf(item) < changes.modified.length - 1) {
        sheet.setRowHeight(row, 5);
        row += 1;
      }
    });
    row += 2;
  }
  
  // ===== í•˜ë‹¨ ì„œëª… ì„¹ì…˜ =====
  sheet.getRange(row, 1, 1, 8).setBorder(true, false, false, false, false, false, '#dadce0', SpreadsheetApp.BorderStyle.SOLID);
  row += 1;
  sheet.getRange(row, 1).setValue('ğŸ“ ë³¸ ë³´ê³ ì„œëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
  sheet.getRange(row, 1).setFontSize(10).setFontColor('#5f6368').setFontStyle('italic');
  
  // ì—´ ë„ˆë¹„ ìµœì í™”
  sheet.setColumnWidth(1, 50);   // No.
  sheet.setColumnWidth(2, 100);  // ì„±ëª…
  sheet.setColumnWidth(3, 150);  // ë³€ê²½ í•­ëª© / ì§ê¸‰
  sheet.setColumnWidth(4, 200);  // ì´ì „ ê°’ / ì§ë ¬
  sheet.setColumnWidth(5, 30);   // í™”ì‚´í‘œ / ëŒ€í•™
  sheet.setColumnWidth(6, 200);  // ë³€ê²½ ê°’ / ì†Œì†
  sheet.setColumnWidth(7, 100);  // ì¤‘ìš”ë„ / ì¬ì§êµ¬ë¶„
  sheet.setColumnWidth(8, 100);  // ë¹„ê³ 
  
  // ì‹œíŠ¸ í”ŒëŸ¬ì‹œ
  SpreadsheetApp.flush();
}

/**
 * ê°’ì„ í‘œì‹œìš©ìœ¼ë¡œ í¬ë§·í•˜ëŠ” í•¨ìˆ˜
 */
function formatValue(value) {
  if (!value || value === '') {
    return '(ë¹„ì–´ìˆìŒ)';
  }
  if (value instanceof Date) {
    return Utilities.formatDate(value, 'GMT+9', 'yyyy.MM.dd');
  }
  return value.toString();
}
